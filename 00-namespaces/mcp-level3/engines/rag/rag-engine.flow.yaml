# MCP Level 3 - RAG Engine Flow Definitions
# Defines workflow orchestration and execution patterns

apiVersion: mcp.ninjatech.ai/v1alpha1
kind: EngineFlow
metadata:
  name: rag-engine
  namespace: mcp-level3
  version: 1.0.0
  description: "RAG Engine workflow definitions and orchestration patterns"
  labels:
    engine-type: rag
    flow-type: orchestration
  annotations:
    mcp.ninjatech.ai/flow-version: "1.0.0"
    mcp.ninjatech.ai/last-updated: "2024-01-11"

# ============================================================================
# WORKFLOW DEFINITIONS
# ============================================================================

workflows:
  # Query Processing Workflow
  - name: query-processing
    description: "End-to-end query processing workflow"
    type: sequential
    trigger:
      type: api
      endpoint: "/api/v1/rag/query"
      method: POST
    
    input:
      schema:
        type: object
        required: [query]
        properties:
          query:
            type: string
            description: "User query text"
          retrieval_strategy:
            type: string
            enum: [vector, graph, hybrid]
            default: hybrid
          top_k:
            type: integer
            default: 10
          generation_config:
            type: object
    
    steps:
      - id: validate-input
        name: "Validate Input"
        type: validation
        action: validate_query_input
        input:
          query: "{{workflow.input.query}}"
        output:
          validated_query: "{{step.result.query}}"
        error_handling:
          on_error: fail
          retry: false
        timeout: 5s
      
      - id: select-retrieval-strategy
        name: "Select Retrieval Strategy"
        type: decision
        condition: "{{workflow.input.retrieval_strategy}}"
        branches:
          - case: vector
            next: vector-retrieval
          - case: graph
            next: graph-retrieval
          - case: hybrid
            next: hybrid-retrieval
          - default: hybrid-retrieval
      
      - id: vector-retrieval
        name: "Vector Retrieval"
        type: service-call
        service: vector-retrieval-service
        action: retrieve
        input:
          query: "{{steps.validate-input.output.validated_query}}"
          top_k: "{{workflow.input.top_k}}"
        output:
          vector_results: "{{step.result.results}}"
        error_handling:
          on_error: retry
          max_retries: 3
          backoff: exponential
        timeout: 2s
        next: generate-answer
      
      - id: graph-retrieval
        name: "Graph Retrieval"
        type: service-call
        service: graph-retrieval-service
        action: retrieve
        input:
          query: "{{steps.validate-input.output.validated_query}}"
          max_depth: 3
        output:
          graph_results: "{{step.result.triplets}}"
        error_handling:
          on_error: retry
          max_retries: 3
          backoff: exponential
        timeout: 3s
        next: generate-answer
      
      - id: hybrid-retrieval
        name: "Hybrid Retrieval"
        type: parallel
        branches:
          - id: vector-branch
            steps:
              - id: vector-retrieve
                type: service-call
                service: vector-retrieval-service
                action: retrieve
                input:
                  query: "{{steps.validate-input.output.validated_query}}"
                  top_k: "{{workflow.input.top_k}}"
                output:
                  vector_results: "{{step.result.results}}"
          
          - id: graph-branch
            steps:
              - id: graph-retrieve
                type: service-call
                service: graph-retrieval-service
                action: retrieve
                input:
                  query: "{{steps.validate-input.output.validated_query}}"
                  max_depth: 3
                output:
                  graph_results: "{{step.result.triplets}}"
        
        join:
          type: all
          timeout: 5s
        
        output:
          vector_results: "{{branches.vector-branch.vector-retrieve.output.vector_results}}"
          graph_results: "{{branches.graph-branch.graph-retrieve.output.graph_results}}"
        
        next: fuse-results
      
      - id: fuse-results
        name: "Fuse Results"
        type: service-call
        service: hybrid-retrieval-service
        action: fuse
        input:
          vector_results: "{{steps.hybrid-retrieval.output.vector_results}}"
          graph_results: "{{steps.hybrid-retrieval.output.graph_results}}"
          fusion_strategy: rrf
        output:
          fused_results: "{{step.result.fused_results}}"
        timeout: 1s
        next: generate-answer
      
      - id: generate-answer
        name: "Generate Answer"
        type: service-call
        service: answer-generation-service
        action: generate
        input:
          query: "{{steps.validate-input.output.validated_query}}"
          context: "{{steps.*.output.*_results}}"
          config: "{{workflow.input.generation_config}}"
        output:
          answer: "{{step.result.answer}}"
          sources: "{{step.result.sources}}"
          confidence: "{{step.result.confidence}}"
        error_handling:
          on_error: retry
          max_retries: 2
          backoff: linear
        timeout: 30s
        next: log-metrics
      
      - id: log-metrics
        name: "Log Metrics"
        type: async
        action: log_query_metrics
        input:
          query: "{{workflow.input.query}}"
          retrieval_time: "{{steps.*.duration}}"
          generation_time: "{{steps.generate-answer.duration}}"
          total_time: "{{workflow.duration}}"
        next: return-response
      
      - id: return-response
        name: "Return Response"
        type: output
        output:
          answer: "{{steps.generate-answer.output.answer}}"
          sources: "{{steps.generate-answer.output.sources}}"
          confidence: "{{steps.generate-answer.output.confidence}}"
          metadata:
            retrieval_strategy: "{{workflow.input.retrieval_strategy}}"
            total_time: "{{workflow.duration}}"
    
    output:
      schema:
        type: object
        properties:
          answer:
            type: string
          sources:
            type: array
          confidence:
            type: number
          metadata:
            type: object
    
    error_handling:
      global:
        on_error: rollback
        notify: ["ops-team@ninjatech.ai"]
    
    monitoring:
      metrics:
        - workflow_duration
        - step_duration
        - error_rate
        - success_rate
      alerts:
        - condition: "workflow.duration > 10s"
          severity: warning
        - condition: "workflow.error_rate > 0.05"
          severity: critical

  # Document Indexing Workflow
  - name: document-indexing
    description: "Document indexing and embedding workflow"
    type: sequential
    trigger:
      type: event
      source: kafka
      topic: documents.uploaded
    
    input:
      schema:
        type: object
        required: [documents, collection]
        properties:
          documents:
            type: array
          collection:
            type: string
          chunking_strategy:
            type: string
            default: semantic
    
    steps:
      - id: validate-documents
        name: "Validate Documents"
        type: validation
        action: validate_documents
        input:
          documents: "{{workflow.input.documents}}"
        output:
          validated_documents: "{{step.result.documents}}"
        timeout: 10s
      
      - id: chunk-documents
        name: "Chunk Documents"
        type: service-call
        service: indexing-service
        action: chunk
        input:
          documents: "{{steps.validate-documents.output.validated_documents}}"
          strategy: "{{workflow.input.chunking_strategy}}"
        output:
          chunks: "{{step.result.chunks}}"
        timeout: 30s
      
      - id: generate-embeddings
        name: "Generate Embeddings"
        type: batch
        service: embedding-service
        action: embed
        input:
          chunks: "{{steps.chunk-documents.output.chunks}}"
        batch_size: 100
        parallel: true
        max_workers: 10
        output:
          embeddings: "{{step.result.embeddings}}"
        timeout: 60s
      
      - id: store-vectors
        name: "Store Vectors"
        type: service-call
        service: vector-database
        action: insert
        input:
          embeddings: "{{steps.generate-embeddings.output.embeddings}}"
          collection: "{{workflow.input.collection}}"
        output:
          inserted_count: "{{step.result.count}}"
        timeout: 30s
      
      - id: extract-entities
        name: "Extract Entities"
        type: service-call
        service: graph-service
        action: extract_entities
        input:
          chunks: "{{steps.chunk-documents.output.chunks}}"
        output:
          entities: "{{step.result.entities}}"
          relationships: "{{step.result.relationships}}"
        timeout: 60s
      
      - id: store-graph
        name: "Store Knowledge Graph"
        type: service-call
        service: graph-database
        action: insert
        input:
          entities: "{{steps.extract-entities.output.entities}}"
          relationships: "{{steps.extract-entities.output.relationships}}"
        output:
          graph_updated: "{{step.result.success}}"
        timeout: 30s
      
      - id: update-metadata
        name: "Update Metadata"
        type: service-call
        service: metadata-store
        action: update
        input:
          collection: "{{workflow.input.collection}}"
          document_count: "{{steps.store-vectors.output.inserted_count}}"
          indexed_at: "{{workflow.timestamp}}"
        timeout: 10s
      
      - id: publish-completion
        name: "Publish Completion Event"
        type: event
        action: publish
        target:
          type: kafka
          topic: rag.indexing.completed
        payload:
          collection: "{{workflow.input.collection}}"
          documents_indexed: "{{steps.store-vectors.output.inserted_count}}"
          duration: "{{workflow.duration}}"
    
    error_handling:
      global:
        on_error: retry
        max_retries: 3
        notify: ["data-team@ninjatech.ai"]

  # Collection Management Workflow
  - name: collection-management
    description: "Create and manage vector collections"
    type: sequential
    trigger:
      type: api
      endpoint: "/api/v1/rag/collections"
      method: POST
    
    input:
      schema:
        type: object
        required: [name, embedding_model]
        properties:
          name:
            type: string
          embedding_model:
            type: string
          dimension:
            type: integer
    
    steps:
      - id: validate-collection
        name: "Validate Collection"
        type: validation
        action: validate_collection_config
        input:
          name: "{{workflow.input.name}}"
          embedding_model: "{{workflow.input.embedding_model}}"
        timeout: 5s
      
      - id: create-vector-collection
        name: "Create Vector Collection"
        type: service-call
        service: vector-database
        action: create_collection
        input:
          name: "{{workflow.input.name}}"
          dimension: "{{workflow.input.dimension}}"
        output:
          collection_id: "{{step.result.id}}"
        timeout: 10s
      
      - id: create-metadata-entry
        name: "Create Metadata Entry"
        type: service-call
        service: metadata-store
        action: create
        input:
          collection_id: "{{steps.create-vector-collection.output.collection_id}}"
          name: "{{workflow.input.name}}"
          embedding_model: "{{workflow.input.embedding_model}}"
          created_at: "{{workflow.timestamp}}"
        timeout: 5s
      
      - id: initialize-cache
        name: "Initialize Cache"
        type: service-call
        service: cache-store
        action: initialize
        input:
          collection_id: "{{steps.create-vector-collection.output.collection_id}}"
        timeout: 5s
    
    output:
      schema:
        type: object
        properties:
          collection_id:
            type: string
          name:
            type: string
          status:
            type: string

# ============================================================================
# CONDITIONAL WORKFLOWS
# ============================================================================

conditional_workflows:
  - name: adaptive-retrieval
    description: "Adaptively select retrieval strategy based on query characteristics"
    conditions:
      - if: "query.length < 50"
        then: vector-retrieval
      - if: "query.contains_entities"
        then: graph-retrieval
      - if: "query.complexity == 'high'"
        then: hybrid-retrieval
      - default: vector-retrieval

# ============================================================================
# ERROR HANDLING PATTERNS
# ============================================================================

error_handling:
  patterns:
    - name: retry-with-backoff
      strategy: exponential
      max_retries: 3
      initial_delay: 1s
      max_delay: 10s
    
    - name: circuit-breaker
      failure_threshold: 5
      timeout: 30s
      half_open_requests: 3
    
    - name: fallback
      primary: vector-retrieval
      fallback: cache-lookup
      condition: "primary.error_rate > 0.1"

# ============================================================================
# STATE MANAGEMENT
# ============================================================================

state_management:
  storage: redis
  ttl: 3600
  persistence: true
  
  states:
    - name: query-in-progress
      transitions:
        - from: started
          to: retrieving
          condition: "step == 'vector-retrieval'"
        - from: retrieving
          to: generating
          condition: "step == 'generate-answer'"
        - from: generating
          to: completed
          condition: "step == 'return-response'"

# ============================================================================
# MONITORING & OBSERVABILITY
# ============================================================================

monitoring:
  metrics:
    - name: workflow_execution_time
      type: histogram
      labels: [workflow_name, status]
    
    - name: step_execution_time
      type: histogram
      labels: [workflow_name, step_name]
    
    - name: workflow_error_rate
      type: counter
      labels: [workflow_name, error_type]
  
  tracing:
    enabled: true
    provider: jaeger
    sample_rate: 0.1
  
  logging:
    level: info
    format: json
    fields:
      - workflow_id
      - step_id
      - duration
      - status

# ============================================================================
# DOCUMENTATION
# ============================================================================

documentation:
  workflow_guide: "https://docs.ninjatech.ai/mcp/rag-engine/workflows"
  examples: "https://github.com/ninjatech/mcp-examples/rag/flows"